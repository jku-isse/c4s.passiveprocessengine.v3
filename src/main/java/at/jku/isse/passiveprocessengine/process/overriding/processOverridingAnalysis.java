package at.jku.isse.passiveprocessengine.process.overriding;

import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import at.jku.isse.designspace.core.model.InstanceType;
import at.jku.isse.designspace.core.model.Workspace;
import at.jku.isse.designspace.rule.arl.expressions.Expression;
import at.jku.isse.designspace.rule.arl.expressions.RootExpression;
import at.jku.isse.designspace.rule.arl.parser.ArlParser;
import at.jku.isse.designspace.rule.arl.parser.ArlType;
import at.jku.isse.designspace.rule.model.ConsistencyRuleType;
import at.jku.isse.passiveprocessengine.definition.ProcessDefinition;
import at.jku.isse.passiveprocessengine.definition.ProcessDefinitionError;
import at.jku.isse.passiveprocessengine.definition.serialization.DTOs;
import at.jku.isse.passiveprocessengine.definition.serialization.DTOs.Constraint;
import at.jku.isse.passiveprocessengine.definition.serialization.DTOs.Process;
import at.jku.isse.passiveprocessengine.definition.serialization.DTOs.Step;
import at.jku.isse.passiveprocessengine.instance.ProcessInstance;
import at.jku.isse.passiveprocessengine.instance.ProcessStep;
import at.jku.isse.passiveprocessengine.instance.StepLifecycle.Conditions;
import io.grpc.ManagedChannelProvider.NewChannelBuilderResult;

public class processOverridingAnalysis {
	ProcessDefinition pd;
	List<ProcessDefinitionError> errors;
	Workspace ws;
	public processOverridingAnalysis(ProcessDefinition process, List<ProcessDefinitionError> errors,Workspace ws) {
		super();
		this.pd = process;
		this.errors = errors;
		this.ws=ws;
	}
	public processOverridingAnalysis() {
		super();
		this.pd=null;
		this.errors= new LinkedList<>();
		this.ws=null;
	}
	public String getConstraintName(Conditions condition, int specOrderIndex, InstanceType stepType) {
		return "crd_"+condition+specOrderIndex+"_"+stepType.name();
	}
	public List<ProcessDefinitionError> beginAnalysis(ProcessDefinition process, List<ProcessDefinitionError> errors,Workspace ws) {
		this.pd=process;
		this.errors=errors;
		InstanceType processInstanceType = ProcessInstance.getOrCreateDesignSpaceInstanceType(ws, this.pd);
		this.pd.getStepDefinitions().stream().forEach(sd->{
			if(sd instanceof ProcessDefinition) // process inside process?? 
			{
				// Might have to circle back to this if we get nested processes.
			}
			else
			{
				InstanceType stepType=ProcessStep.getOrCreateDesignSpaceInstanceType(ws, sd, processInstanceType);
				sd.getPreconditions().stream().forEach(pre->{
					String specId = getConstraintName(Conditions.PRECONDITION, pre.getOrderIndex(), stepType);
					String arl=pre.getAugmentedConstraintSpec();
					if (arl!= null) {						
						/* Most probably we dn't need this but for now just keep it here commented just in case.
						 try {  
							arl = rewriteConstraint(arl);
							System.out.println(String.format("Augmented constraint %s for %s to %s", specId, sd.getName(), arl));
							pre.setAugmentedConstraintSpec(arl);
						} catch(Exception e) {
							errors.add(new ProcessDefinitionError(sd, String.format("Error aumenting Constraint %s : %s", specId, arl), e.getMessage()));
						}*/
						ArlParser parser = new ArlParser();
						ConsistencyRuleType crt = ConsistencyRuleType.create(ws, stepType, specId, arl);
						ArlType contextType=ArlType.get(ArlType.TypeKind.INSTANCE, ArlType.CollectionKind.SINGLE, crt.contextInstanceType());
						Expression syntaxTree = new RootExpression((Expression) parser.parse(arl, 
								contextType, 
								null));
						System.out.println("WE DID IT");
						//TODO might need to do the data mappings as well before storing them. let's see 
						//TODO Now we need to store all the trees (overirdeable and not overrideable) along with their names into two separate list.
					}
				});
			}
		});
		//step 1: extract conditions that are overrideable as well as not autogenerated 
		//TODO: how to know which ones are coming after the overrideable conditions
		return null;
	}
	
	
	

}
