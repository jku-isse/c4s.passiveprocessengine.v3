package at.jku.isse.passiveprocessengine.process.overriding;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import at.jku.isse.designspace.core.model.InstanceType;
import at.jku.isse.designspace.core.model.Workspace;
import at.jku.isse.designspace.rule.arl.expressions.Expression;
import at.jku.isse.designspace.rule.arl.expressions.RootExpression;
import at.jku.isse.designspace.rule.arl.parser.ArlParser;
import at.jku.isse.designspace.rule.arl.parser.ArlType;
import at.jku.isse.designspace.rule.model.ConsistencyRuleType;
import at.jku.isse.designspace.rule.overriding.OverridingConstraintData;
import at.jku.isse.passiveprocessengine.definition.ConstraintSpec;
import at.jku.isse.passiveprocessengine.definition.ProcessDefinition;
import at.jku.isse.passiveprocessengine.definition.ProcessDefinitionError;
import at.jku.isse.passiveprocessengine.definition.StepDefinition;
import at.jku.isse.passiveprocessengine.instance.ProcessInstance;
import at.jku.isse.passiveprocessengine.instance.ProcessStep;
import at.jku.isse.passiveprocessengine.instance.StepLifecycle.Conditions;

public class ProcessOverridingAnalysis {
	ProcessDefinition pd;
	List<ProcessDefinitionError> errors;
	Workspace ws;
	Expression overridableExp=null;
	Map<String,String> mappings=new HashMap<>();
	List<OverridingConstraintData> ovc_list=new LinkedList<>();
	public ProcessOverridingAnalysis(ProcessDefinition process, List<ProcessDefinitionError> errors,Workspace ws) {
		super();
		this.pd = process;
		this.errors = errors;
		this.ws=ws;
	}
	public ProcessOverridingAnalysis() {
		super();
		this.pd=null;
		this.errors= new LinkedList<>();
		this.ws=null;
	}
	public String getConstraintName(Conditions condition, int specOrderIndex, InstanceType stepType) {
		return "crd_"+condition+specOrderIndex+"_"+stepType.name();
	}
	//TODO: Multiple overridedTrees as well as the sequence
	public List<String> beginAnalysis(ProcessDefinition process, List<String> warnings,Workspace ws) {
		this.ovc_list.clear();
		this.pd=process;
		this.errors=errors;
		this.ws=ws;
		InstanceType processInstanceType = ProcessInstance.getOrCreateDesignSpaceInstanceType(ws, this.pd);
		this.pd.getStepDefinitions().stream().forEach(sd->{
			InstanceType stepType=ProcessStep.getOrCreateDesignSpaceInstanceType(ws, sd, processInstanceType);
			if(sd instanceof ProcessDefinition) // process inside process?? 
			{// Might have to circle back to this if we get nested processes.//TODO: Sol:nested call to the beginAnalysis
			}
			else
			{
				// 1: Extraction of IO Mappings of the Step (TODO: Discuss)
				// extractingIOMappings(sd);
				// 2: Going through Constraints In Order
				// 2.1: Pre Conditions
				sd.getPreconditions().stream().forEach(pre->{
					String specId = getConstraintName(Conditions.PRECONDITION, pre.getOrderIndex(), stepType);
					String arl=pre.getAugmentedConstraintSpec();
					if (arl!= null && pre.getInstance().getPropertyAsValue("isOverridable").equals(true)) {						
						generateOverridingData(stepType,specId,arl);
					}//else do nothing TODO: if previous step have then we might need to check discuss.
				});
				// 2.2: QA Constraints 
				sd.getQAConstraints().stream().forEach(qa->{
					String specId = getConstraintName(Conditions.QA, qa.getOrderIndex(), stepType);
					String arl=qa.getAugmentedConstraintSpec();
					if(arl!=null && qa.getInstance().getPropertyAsValue("isOverridable").equals(false) && overridableExp!=null) 
					{
						//Completing IO mappings into the Constraint.Code is here decide later if needed or not
						//arl=embeddingIOMappingIntoConstraint(arl);
						checkImpact(stepType, specId, arl, qa, warnings);
					}
					else if(arl!=null && qa.getInstance().getPropertyAsValue("isOverridable").equals(true))
					{
						generateOverridingData(stepType,specId,arl);
					}
				});
				// 2.3: Post Conditions 
				sd.getPostconditions().stream().forEach(post->{
					String specId = getConstraintName(Conditions.POSTCONDITION, post.getOrderIndex(), stepType);
					String arl=post.getAugmentedConstraintSpec();
					if(arl!=null && post.getInstance().getPropertyAsValue("isOverridable").equals(false) && overridableExp!=null) 
					{
						//Completing IO mappings into the Constraint.Code is here decide later if needed or not
						//arl=embeddingIOMappingIntoConstraint(arl);
						checkImpact(stepType, specId, arl, post, warnings);
					}
					else if(arl!=null && post.getInstance().getPropertyAsValue("isOverridable").equals(true))
					{
						generateOverridingData(stepType,specId,arl);
					}
				});
			}
		});
		//step 1: extract conditions that are overrideable as well as not autogenerated 
		//TODO: how to know which ones are coming after the overrideable conditions
		return warnings;
	}
	
	public void generateOverridingData(InstanceType stepType,String specId,String arl)
	{
		overridableExp=generateSyntaxTree(stepType,specId,arl);
		OverridingConstraintData ovc=new OverridingConstraintData();
		overridableExp.getOverridingData(ovc,null);
		ovc_list.add(ovc);
	}
	
	public void checkImpact(InstanceType stepType,String specId,String arl,ConstraintSpec rule,List<String> warnings)
	{
		Expression syntaxTree=generateSyntaxTree(stepType,specId,arl);
		for(OverridingConstraintData ovc:ovc_list)
		{
			String res=syntaxTree.isReachable(ovc,null);
			if(res.equals("0"))
			{
				warnings.add(rule.getName()+" 'IsOverrideable' property might require to be ENABLED.");
			}
			else if(res.equals("-1"))
			{
				warnings.add(rule.getName()+" 'IsOverrideable' property must be ENABLED.");
			}
		}
	}

	public String embeddingIOMappingIntoConstraint(String arl)
	{
		for (Map.Entry<String, String> mapping : mappings.entrySet()) {
			if(arl.contains(mapping.getKey()))
			{
				arl=arl.replace(mapping.getKey(), mapping.getValue());
			}
		}
		return arl;
	}

	public Expression generateSyntaxTree(InstanceType stepType,String specID,String arl)
	{
		ArlParser parser = new ArlParser();
		ConsistencyRuleType crt = ConsistencyRuleType.create(ws, stepType, specID, arl);
		ArlType contextType=ArlType.get(ArlType.TypeKind.INSTANCE, ArlType.CollectionKind.SINGLE, crt.contextInstanceType());
		return new RootExpression((Expression) parser.parse(arl, contextType, null));
	}

	public void extractingIOMappings(StepDefinition sd)
	{
		Map<String, String> IoMappings= sd.getInputToOutputMappingRules();
		if(IoMappings.size()>0)
		{
			for (Map.Entry<String, String> mapping : IoMappings.entrySet()) {
				String key = mapping.getKey();
				String value = mapping.getValue();
				mappings.put("self.out_"+key, value);
			}
		}	
	}




}
