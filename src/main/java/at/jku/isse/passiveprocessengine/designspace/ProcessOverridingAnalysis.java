package at.jku.isse.passiveprocessengine.designspace;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import at.jku.isse.designspace.rule.arl.expressions.Expression;
import at.jku.isse.designspace.rule.arl.expressions.RootExpression;
import at.jku.isse.designspace.rule.arl.parser.ArlParser;
import at.jku.isse.designspace.rule.arl.parser.ArlType;
import at.jku.isse.designspace.rule.overriding.ConstraintContext;
import at.jku.isse.designspace.rule.overriding.OverridingConstraintData;
import at.jku.isse.passiveprocessengine.core.PPEInstanceType;
import at.jku.isse.passiveprocessengine.core.ProcessContext;
import at.jku.isse.passiveprocessengine.core.RuleAnalysisService.OverrideAnalysisSession;
import at.jku.isse.passiveprocessengine.definition.ProcessDefinitionError;
import at.jku.isse.passiveprocessengine.definition.activeobjects.ConstraintSpec;
import at.jku.isse.passiveprocessengine.definition.activeobjects.ProcessDefinition;
import at.jku.isse.passiveprocessengine.definition.activeobjects.StepDefinition;
import at.jku.isse.passiveprocessengine.definition.factories.ProcessDefinitionFactory;
import at.jku.isse.passiveprocessengine.instance.StepLifecycle.Conditions;
import at.jku.isse.passiveprocessengine.instance.types.SpecificProcessStepType;


public class ProcessOverridingAnalysis {
	private static final String CONSTRAINT_OVERRIDING_WARNING = "ConstraintOverridingWarning";

	private final ProcessContext context;

	
	private Map<String,String> mappingFromConstraintToItemType=new HashMap<>();


	public ProcessOverridingAnalysis(ProcessContext context) {
		this.context = context;
	}
//	public String getConstraintName(Conditions condition, int specOrderIndex, InstanceType stepType) {
//		return "crd_"+condition+specOrderIndex+"_"+stepType.name();
//	}
	
	//TODO: Multiple overridedTrees as well as the sequence
	public List<ProcessDefinitionError> beginAnalysis(ProcessDefinition process, List<ProcessDefinitionError> warnings) {
		OverrideAnalysisSession oas = context.getRuleAnalysisService().createSession();
		
		throw new RuntimeException("Not implemented completely");
		
//		process.getStepDefinitions().stream().forEach(sd->{
//			PPEInstanceType stepType = context.getSchemaRegistry().getTypeByName(SpecificProcessStepType.getProcessStepName(sd));
//			if(sd instanceof ProcessDefinition) // process inside process?? 
//			{// Might have to circle back to this if we get nested processes.//TODO: Sol:nested call to the beginAnalysis
//			}
//			else
//			{
//				// 1: Extraction of IO Mappings of the Step (TODO: Discuss)
//				// extractingIOMappings(sd);
//				// 2: Going through Constraints In Order
//				// 2.1: Pre Conditions
//				sd.getPreconditions().stream().forEach(pre->{
//					
//					String specId = ProcessDefinitionFactory.getConstraintName(Conditions.PRECONDITION, pre.getOrderIndex(), stepType);
//					String arl=pre.getAugmentedConstraintSpec();
//					if (arl!= null && pre.isOverridable()) {						
//						oas.generateOverridingData(stepType,specId,arl);
//					}//else do nothing TODO: if previous step have then we might need to check discuss.
//				});
//				// 2.2: QA Constraints 
//				sd.getQAConstraints().stream().forEach(qa->{
//					String specId = ProcessDefinitionFactory.getConstraintName(Conditions.QA, qa.getOrderIndex(), stepType);
//					String arl=qa.getAugmentedConstraintSpec();
//					if(arl!=null && !qa.isOverridable() && oas.isCurrentRuleAnalyzable()) 
//					{
//						//Completing IO mappings into the Constraint.Code is here decide later if needed or not
//						//arl=embeddingIOMappingIntoConstraint(arl);
//						inferImpact(oas, stepType, specId, arl, qa, warnings);
//					}
//					else if(arl!=null && qa.isOverridable())
//					{
//						oas.generateOverridingData(stepType,specId,arl);
//					}
//				});
//				// 2.3: Post Conditions 
//				sd.getPostconditions().stream().forEach(post->{
//					String specId = ProcessDefinitionFactory.getConstraintName(Conditions.POSTCONDITION, post.getOrderIndex(), stepType);
//					String arl=post.getAugmentedConstraintSpec();
//					if(arl!=null && !post.isOverridable() && oas.isCurrentRuleAnalyzable()) 
//					{
//						//Completing IO mappings into the Constraint.Code is here decide later if needed or not
//						//arl=embeddingIOMappingIntoConstraint(arl);
//						inferImpact(oas, stepType, specId, arl, post, warnings);
//					}
//					else if(arl!=null && post.isOverridable())
//					{
//						oas.generateOverridingData(stepType,specId,arl);
//					}
//				});
//			}
//		});
//		//step 1: extract conditions that are overrideable as well as not autogenerated 
//		//TODO: how to know which ones are coming after the overrideable conditions
//		return warnings;
	}		
	
	public void inferImpact(OverrideAnalysisSession oas, PPEInstanceType stepType,String specId,String arl,ConstraintSpec rule,List<ProcessDefinitionError> warnings)
	{
		Map<String, Integer> impactResult = oas.inferImpact(stepType, specId, arl);						
		impactResult.entrySet().stream().forEach( entry -> {								
			if(entry.getValue()==0)
			{
				warnings.add(new ProcessDefinitionError(rule, CONSTRAINT_OVERRIDING_WARNING , rule.getName()+" 'IsOverrideable' property might require to be ENABLED.", ProcessDefinitionError.Severity.INFO));
			}
			else if(entry.getValue()==-1)
			{
				warnings.add(new ProcessDefinitionError(rule, CONSTRAINT_OVERRIDING_WARNING ,rule.getName()+" 'IsOverrideable' property must be ENABLED.", ProcessDefinitionError.Severity.WARNING));
			}
			/*String res=ovc.doesContainSameContext(context);
			if(res.equals("0"))
			{
				warnings.add(new ProcessDefinitionError(rule, CONSTRAINT_OVERRIDING_WARNING , rule.getName()+" 'IsOverrideable' property might require to be ENABLED."));
			}
			else if(res.equals("-1"))
			{
				warnings.add(new ProcessDefinitionError(rule, CONSTRAINT_OVERRIDING_WARNING ,rule.getName()+" 'IsOverrideable' property must be ENABLED."));
			}*/
		});
	}
	
	/*public void checkImpact(PPEInstanceType stepType, String specId, String arl, ConstraintSpec rule, List<ProcessDefinitionError> warnings)
	{
		InstanceType type = (InstanceType) abstractionMapper.mapProcessDomainInstanceTypeToDesignspaceInstanceType(stepType);
		Expression syntaxTree=generateSyntaxTree(type,specId,arl);
		for(OverridingConstraintData ovc:ovc_list)
		{
			String res=syntaxTree.isReachable(ovc,null); //TIM is created in Rootnode
			if(res.equals("0"))
			{
				warnings.add(new ProcessDefinitionError(rule, CONSTRAINT_OVERRIDING_WARNING , rule.getName()+" 'IsOverrideable' property might require to be ENABLED.", ProcessDefinitionError.Severity.INFO));
			}
			else if(res.equals("-1"))
			{
				warnings.add(new ProcessDefinitionError(rule, CONSTRAINT_OVERRIDING_WARNING ,rule.getName()+" 'IsOverrideable' property must be ENABLED.", ProcessDefinitionError.Severity.WARNING));
			}
		}
	}
*/
//	public String embeddingIOMappingIntoConstraint(String arl)
//	{
//		for (Map.Entry<String, String> mapping : mappingFromConstraintToItemType.entrySet()) {
//			if(arl.contains(mapping.getKey()))
//			{
//				arl=arl.replace(mapping.getKey(), mapping.getValue());
//			}
//		}
//		return arl;
//	}
//
//
//
//	public void extractingIOMappings(StepDefinition sd)
//	{
//		Map<String, String> IoMappings= sd.getInputToOutputMappingRules();
//		if(IoMappings.size()>0)
//		{
//			for (Map.Entry<String, String> mapping : IoMappings.entrySet()) {
//				String key = mapping.getKey();
//				String value = mapping.getValue();
//				mappingFromConstraintToItemType.put("self.out_"+key, value);
//			}
//		}	
//	}




}

