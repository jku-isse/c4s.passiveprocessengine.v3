package at.jku.isse.passiveprocessengine.designspace;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import at.jku.isse.designspace.core.model.InstanceType;
import at.jku.isse.designspace.rule.arl.expressions.Expression;
import at.jku.isse.designspace.rule.arl.expressions.RootExpression;
import at.jku.isse.designspace.rule.arl.parser.ArlParser;
import at.jku.isse.designspace.rule.arl.parser.ArlType;
import at.jku.isse.designspace.rule.overriding.OverridingConstraintData;
import at.jku.isse.passiveprocessengine.core.PPEInstanceType;
import at.jku.isse.passiveprocessengine.core.ProcessContext;
import at.jku.isse.passiveprocessengine.definition.ProcessDefinitionError;
import at.jku.isse.passiveprocessengine.definition.activeobjects.ConstraintSpec;
import at.jku.isse.passiveprocessengine.definition.activeobjects.ProcessDefinition;
import at.jku.isse.passiveprocessengine.definition.activeobjects.StepDefinition;
import at.jku.isse.passiveprocessengine.definition.factories.ProcessDefinitionFactory;
import at.jku.isse.passiveprocessengine.instance.StepLifecycle.Conditions;
import at.jku.isse.passiveprocessengine.instance.types.SpecificProcessStepType;


public class ProcessOverridingAnalysis {
	private static final String CONSTRAINT_OVERRIDING_WARNING = "ConstraintOverridingWarning";

	private final ProcessContext context;
	private final DesignspaceAbstractionMapper abstractionMapper;
	
	private Expression overridableExp=null;
	private Map<String,String> mappings=new HashMap<>();
	private List<OverridingConstraintData> ovc_list=new LinkedList<>();

	public ProcessOverridingAnalysis(ProcessContext context, DesignspaceAbstractionMapper abstractionMapper) {
		this.context = context;
		this.abstractionMapper = abstractionMapper;
	}
	
	
	//TODO: Multiple overridedTrees as well as the sequence
	public List<ProcessDefinitionError> beginAnalysis(ProcessDefinition process, List<ProcessDefinitionError> warnings) {
		this.ovc_list.clear();
		
		process.getStepDefinitions().stream().forEach(sd->{
			PPEInstanceType stepType = context.getSchemaRegistry().getTypeByName(SpecificProcessStepType.getProcessStepName(sd));
			if(sd instanceof ProcessDefinition) // process inside process?? 
			{// Might have to circle back to this if we get nested processes.//TODO: Sol:nested call to the beginAnalysis
			}
			else
			{
				// 1: Extraction of IO Mappings of the Step (TODO: Discuss)
				// extractingIOMappings(sd);
				// 2: Going through Constraints In Order
				// 2.1: Pre Conditions
				sd.getPreconditions().stream().forEach(pre->{
					
					String specId = ProcessDefinitionFactory.getConstraintName(Conditions.PRECONDITION, pre.getOrderIndex(), stepType);
					String arl=pre.getAugmentedConstraintSpec();
					if (arl!= null && pre.isOverridable()) {						
						generateOverridingData(stepType,specId,arl);
					}//else do nothing TODO: if previous step have then we might need to check discuss.
				});
				// 2.2: QA Constraints 
				sd.getQAConstraints().stream().forEach(qa->{
					String specId = ProcessDefinitionFactory.getConstraintName(Conditions.QA, qa.getOrderIndex(), stepType);
					String arl=qa.getAugmentedConstraintSpec();
					if(arl!=null && !qa.isOverridable() && overridableExp!=null) 
					{
						//Completing IO mappings into the Constraint.Code is here decide later if needed or not
						//arl=embeddingIOMappingIntoConstraint(arl);
						checkImpact(stepType, specId, arl, qa, warnings);
					}
					else if(arl!=null && qa.isOverridable())
					{
						generateOverridingData(stepType,specId,arl);
					}
				});
				// 2.3: Post Conditions 
				sd.getPostconditions().stream().forEach(post->{
					String specId = ProcessDefinitionFactory.getConstraintName(Conditions.POSTCONDITION, post.getOrderIndex(), stepType);
					String arl=post.getAugmentedConstraintSpec();
					if(arl!=null && !post.isOverridable() && overridableExp!=null) 
					{
						//Completing IO mappings into the Constraint.Code is here decide later if needed or not
						//arl=embeddingIOMappingIntoConstraint(arl);
						checkImpact(stepType, specId, arl, post, warnings);
					}
					else if(arl!=null && post.isOverridable())
					{
						generateOverridingData(stepType,specId,arl);
					}
				});
			}
		});
		//step 1: extract conditions that are overrideable as well as not autogenerated 
		//TODO: how to know which ones are coming after the overrideable conditions
		return warnings;
	}
	
	public void generateOverridingData(PPEInstanceType stepType,String specId,String arl)
	{
//		InstanceType type = (InstanceType) abstractionMapper.mapProcessDomainInstanceTypeToDesignspaceInstanceType(stepType);
//		overridableExp=generateSyntaxTree(type,specId,arl);
//		OverridingConstraintData ovc=new OverridingConstraintData();
//		overridableExp.getOverridingData(ovc,null); //TIM is created in Rootnode
//		ovc_list.add(ovc);
	}
	
	public void checkImpact(PPEInstanceType stepType, String specId, String arl, ConstraintSpec rule, List<ProcessDefinitionError> warnings)
	{
//		InstanceType type = (InstanceType) abstractionMapper.mapProcessDomainInstanceTypeToDesignspaceInstanceType(stepType);
//		Expression syntaxTree=generateSyntaxTree(type,specId,arl);
//		for(OverridingConstraintData ovc:ovc_list)
//		{
//			String res=syntaxTree.isReachable(ovc,null); //TIM is created in Rootnode
//			if(res.equals("0"))
//			{
//				warnings.add(new ProcessDefinitionError(rule, CONSTRAINT_OVERRIDING_WARNING , rule.getName()+" 'IsOverrideable' property might require to be ENABLED.", ProcessDefinitionError.Severity.INFO));
//			}
//			else if(res.equals("-1"))
//			{
//				warnings.add(new ProcessDefinitionError(rule, CONSTRAINT_OVERRIDING_WARNING ,rule.getName()+" 'IsOverrideable' property must be ENABLED.", ProcessDefinitionError.Severity.WARNING));
//			}
//		}
	}

	public String embeddingIOMappingIntoConstraint(String arl)
	{
		for (Map.Entry<String, String> mapping : mappings.entrySet()) {
			if(arl.contains(mapping.getKey()))
			{
				arl=arl.replace(mapping.getKey(), mapping.getValue());
			}
		}
		return arl;
	}

	public Expression generateSyntaxTree(InstanceType stepType,String specID,String arl)
	{
		ArlParser parser = new ArlParser();		
		ArlType contextType=ArlType.get(ArlType.TypeKind.INSTANCE, ArlType.CollectionKind.SINGLE, stepType);
		return new RootExpression((Expression) parser.parse(arl, contextType, null));
	}

	public void extractingIOMappings(StepDefinition sd)
	{
		Map<String, String> IoMappings= sd.getInputToOutputMappingRules();
		if(IoMappings.size()>0)
		{
			for (Map.Entry<String, String> mapping : IoMappings.entrySet()) {
				String key = mapping.getKey();
				String value = mapping.getValue();
				mappings.put("self.out_"+key, value);
			}
		}	
	}




}

